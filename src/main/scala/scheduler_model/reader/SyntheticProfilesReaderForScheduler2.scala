package scheduler_model.reader

import breeze.linalg._
import scheduler_model.load.Load.LoadId
import scheduler_model.load.{AccumulatedLoad, FixedLoad, FlexibleLoad, Load, SingleLoad}
import reader.TemplateForSyntheticProfilesReader
import types.clusterer.DataTypeMetadata

import scala.util.Try

object SyntheticProfilesReaderForScheduler2 extends TemplateForSyntheticProfilesReader {

  override type SingleLoadOutputType = SingleLoad
  override type AccumulatedLoadOutputType = AccumulatedLoad

  def applyDefault(mainFolder: String,
    subFolders: Iterable[String],
    applianceOutputFileName: String,
    lightingOutputFileName: String,
    ids: Iterable[Int],
    windowSize: Int): scala.Vector[AccumulatedLoadOutputType] = {

    apply(
      mainFolder,
      subFolders,
      subFolder => LoadFileAndLoadBuilder(mainFolder + subFolder + applianceOutputFileName, ApplianceLoadBuilder),
      subFolder => LoadFileAndLoadBuilder(mainFolder + subFolder + lightingOutputFileName, FixedLoadBuilder), ids, windowSize
    )
  }

  /**
    *
    * Reads files applianceOutputFileName, lightingOutputFileName for each profile.
    * Directory structure is prepared to be mainFolder/{subFolder}/{applianceOutputFileName|lightingOutputFileName}.
    * Data format is in CSV where there are no column headers and each row starts with a label. The label of the appliance.
    * Data is expected to be synthetically generated by https://github.com/keirstead-group/simelec .
    *
    * @param mainFolder
    * @param subFolders
    * @param applianceFileAndBuilder
    * @param lightingFileAndBuilder
    * @param ids
    * @param windowSize
    * @return
    */
  def apply(mainFolder: String,
    subFolders: Iterable[String],
    applianceFileAndBuilder: String => this.LoadFileAndLoadBuilder,
    lightingFileAndBuilder: String => this.LoadFileAndLoadBuilder,
    ids: Iterable[Int],
    windowSize: Int): scala.Vector[AccumulatedLoadOutputType] = {
    assert(subFolders.size == ids.size, "the number of subFolders is not equal to the number of ids")

    val readFs = subFolders
      .zip(ids)
      .map {
        case (subFolder, _) =>
          val readF: LoadId => (AccumulatedLoad, LoadId) = (idC) => {
            val (loads, lastUsedIdC) = readSyntheticLoads(
              applianceFileAndBuilder(subFolder),
              lightingFileAndBuilder(subFolder),
              windowSize, idC
            )
            val idCForAccumulatedLoad = lastUsedIdC + 1

            (
              AccumulatedLoad(idCForAccumulatedLoad, idCForAccumulatedLoad, "user" + idCForAccumulatedLoad, loads)
              (DataTypeMetadata.generateDataTypeMetadata(loads.length)),
              idCForAccumulatedLoad
            )
          }
          readF
      }

    val (firstAccumulatedLoad, lastUsedLoadId) = readFs.head(0)

    val readAccumulatedLoads = readFs.tail.foldLeft((List(firstAccumulatedLoad), lastUsedLoadId)) { case ((accumulatedLoads, accLastUsedLoadId), readF) =>
      val (_accLoad, _lastUsedLoadId) = readF(accLastUsedLoadId + 1)
      (_accLoad :: accumulatedLoads, _lastUsedLoadId)

    }
    readAccumulatedLoads._1.toVector
  }

  object ApplianceLoadBuilder extends LoadBuilder {

    import Appliances._

    override def apply(id: Int, values: scala.Vector[Double], label: String, replaceWithLabel: Option[String] = None): SingleLoad = {

      val loadLabel = replaceWithLabel.getOrElse(label)

      def createFlexibleLoad(): FlexibleLoad =
        FlexibleLoad(id, 0, loadLabel, 0, DenseVector[Double](values:_*))

      Try(label match {
        case DishWasher => createFlexibleLoad()
        case TumbleDryer => createFlexibleLoad()
        case WashingMachine => createFlexibleLoad()
        case WasherDryer => createFlexibleLoad()
      }).getOrElse(FixedLoadBuilder(id, values, label, replaceWithLabel))
    }
  }

  object FixedLoadBuilder extends LoadBuilder {
    override def apply(id: Int, values: scala.Vector[Double], label: String, replaceWithLabel: Option[String] = None): SingleLoad =
      FixedLoad(id, 0, replaceWithLabel.getOrElse(label), DenseVector[Double](values:_*))
  }

}

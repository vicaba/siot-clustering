package reader

import test.{SingleLoad, SpanSlotAccumulatedLoad, SpanSlotFixedLoad, SpanSlotFlexibleLoad}

object SyntheticProfilesReader extends TemplateForSyntheticProfilesReader {

  override type SingleLoadOutputType = SingleLoad

  override type AccumulatedLoadOutputType = SpanSlotAccumulatedLoad

  def applyDefault(mainFolder: String,
                   subFolders: Iterable[String],
                   applianceOutputFileName: String,
                   lightingOutputFileName: String,
                   ids: Iterable[Int],
                   windowSize: Int): Vector[AccumulatedLoadOutputType] = {

    apply(
      mainFolder,
      subFolders,
      subFolder => LoadFileAndLoadBuilder(mainFolder + subFolder + applianceOutputFileName, new ApplianceLoadBuilder),
      subFolder => LoadFileAndLoadBuilder(mainFolder + subFolder + lightingOutputFileName, new FixedLoadBuilder), ids, windowSize
    )
  }

  /**
    *
    * Reads files applianceOutputFileName, lightingOutputFileName for each profile.
    * Directory structure is prepared to be mainFolder/{subFolder}/{applianceOutputFileName|lightingOutputFileName}.
    * Data format is in CSV where there are no column headers and each row starts with a label. The label of the appliance.
    * Data is expected to be synthetically generated by https://github.com/keirstead-group/simelec .
    *
    * @param mainFolder
    * @param subFolders
    * @param applianceFileAndBuilder
    * @param lightingFileAndBuilder
    * @param ids
    * @param windowSize
    * @return
    */
  def apply(mainFolder: String,
            subFolders: Iterable[String],
            applianceFileAndBuilder: String => this.LoadFileAndLoadBuilder,
            lightingFileAndBuilder: String => this.LoadFileAndLoadBuilder,
            ids: Iterable[Int],
            windowSize: Int): Vector[AccumulatedLoadOutputType] = {
    assert(subFolders.size == ids.size, "the number of subFolders is not equal to the number of ids")

    subFolders
      .zip(ids)
      .map {
        case (subFolder, id) =>
          val l = SpanSlotAccumulatedLoad(id,
                                          0,
                                          readSyntheticLoads(
                                            applianceFileAndBuilder(subFolder),
                                            lightingFileAndBuilder(subFolder),
                                            windowSize
                                          ))
          l

      }
      .toVector
  }

  class ApplianceLoadBuilder extends LoadBuilder {
    import Appliances._
    override def apply(id: Int, values: Vector[Double], label: String): Seq[SingleLoad] =
      List(label match {
        case DishWasher     => SpanSlotFlexibleLoad(id, 0, values, label)
        case TumbleDryer    => SpanSlotFlexibleLoad(id, 0, values, label)
        case WashingMachine => SpanSlotFlexibleLoad(id, 0, values, label)
        case WasherDryer    => SpanSlotFlexibleLoad(id, 0, values, label)
        case _              => SpanSlotFixedLoad(id, 0, values, label)
      })
  }

  class FixedLoadBuilder extends LoadBuilder {
    override def apply(id: Int, values: Vector[Double], label: String): Seq[SingleLoad] =
      List(SpanSlotFixedLoad(id, 0, values, label))
  }

}

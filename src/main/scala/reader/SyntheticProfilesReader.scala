package reader

import test.{SingleLoad, SpanSlotAccumulatedLoad, SpanSlotFixedLoad, SpanSlotFlexibleLoad}

import scala.annotation.tailrec
import scala.collection.immutable
import scala.io.Source
import scala.util.{Random, Try}

object SyntheticProfilesReader {

  def apply(mainFolder: String,
            subFolders: Iterable[String],
            applianceOutputFileName: String,
            lightingOutputFileName: String,
            ids: Iterable[Int],
            windowSize: Int): Vector[SpanSlotAccumulatedLoad] =
    readSyntheticProfiles(mainFolder, subFolders, applianceOutputFileName, lightingOutputFileName, ids, windowSize)

  def splitSequenceBySequenceOfElements[E](seq: Seq[E], sequenceOfElementsValue: E): Seq[(Int, Seq[E])] = {

    case class Extracted(extractedSeq: Seq[E], remainingSeq: Seq[E])

    @tailrec
    def _extractSequenceOfElements(_seq: Seq[E], accum: Seq[E], comparator: (E, E) => Boolean): Extracted = {
      if (_seq.isEmpty) return Extracted(accum, _seq)
      if (comparator(_seq.head, sequenceOfElementsValue))
        _extractSequenceOfElements(_seq.tail, _seq.head +: accum, comparator)
      else Extracted(accum, _seq)
    }

    @tailrec
    def _splitSequenceBySequenceOfElements(index: Int,
                                           remainingSeq: Seq[E],
                                           accum: Seq[(Int, Seq[E])]): Seq[(Int, Seq[E])] = {
      if (remainingSeq.isEmpty) return accum
      if (remainingSeq.head == sequenceOfElementsValue) {
        val extracted = _extractSequenceOfElements(remainingSeq, Seq(), (e1, e2) => e1 == e2)
        _splitSequenceBySequenceOfElements(index + extracted.extractedSeq.length, extracted.remainingSeq, accum)
      } else {
        val extracted = _extractSequenceOfElements(remainingSeq, Seq(), (e1, e2) => e1 != e2)
        _splitSequenceBySequenceOfElements(index + extracted.extractedSeq.length,
                                           extracted.remainingSeq,
                                           (index, extracted.extractedSeq) +: accum)
      }

    }

    _splitSequenceBySequenceOfElements(index = 0, seq, Seq())

  }

  def readSyntheticLoads(applianceOutputFile: String,
                         lightingOutputFile: String,
                         windowSize: Int): Vector[SingleLoad] = {

    trait LoadBuilder extends ((Int, Vector[Double], String) => Seq[SingleLoad]) {
      def apply(id: Int, values: Vector[Double], label: String): Seq[SingleLoad]
    }

    class RandomLoadBuilder extends LoadBuilder {
      override def apply(id: Int, values: Vector[Double], label: String): Seq[SingleLoad] =
        if (Random.nextBoolean()) {
          List(SpanSlotFixedLoad(id, 0, values, label))
        } else {
          List(SpanSlotFlexibleLoad(id, 0, values, label))
        }
    }

    class FixedLoadBuilder extends LoadBuilder {
      override def apply(id: Int, values: Vector[Double], label: String): Seq[SingleLoad] =
        List(SpanSlotFixedLoad(id, 0, values, label))
    }

    def readCsv(file: String, loadBuilder: LoadBuilder)(id: Int): (Int, Vector[SingleLoad]) = {

      var idC    = id
      val source = Source.fromFile(file)

      Try {
        (for {
          line <- source.getLines()
        } yield {
          idC = idC + 1
          val items  = line.split(",").toList
          val label  = items.head
          val values = items.tail.map(_.toDouble).grouped(windowSize).map(_.sum).toVector
          loadBuilder.apply(idC, values, label)
        }).toVector.flatten
      }.map((idC, _))
        .getOrElse {
          source.close()
          (idC, Vector.empty)
        }
    }

    def rec(fs: List[Int => (Int, Vector[SingleLoad])], accId: Int, accLoads: Vector[SingleLoad]): Vector[SingleLoad] =
      fs match {
        case x :: xs =>
          val (idC, loads) = x(accId)
          rec(xs, idC, loads ++: accLoads)
        case Nil => accLoads
      }

    rec(
      List(
        readCsv(applianceOutputFile, new RandomLoadBuilder),
        readCsv(lightingOutputFile, new FixedLoadBuilder)
      ),
      accId = 0,
      Vector.empty[SingleLoad]
    )

  }

  /**
    *
    * Reads files applianceOutputFileName, lightingOutputFileName for each profile.
    * Directory structure is prepared to be mainFolder/{subFolder}/{applianceOutputFileName|lightingOutputFileName}.
    * Data format is in CSV where there are no column headers and each row starts with a label. The label of the appliance.
    * Data is expected to be synthetically generated by https://github.com/keirstead-group/simelec .
    *
    * @param mainFolder
    * @param subFolders
    * @param applianceOutputFileName
    * @param lightingOutputFileName
    * @param ids
    * @param windowSize
    * @return
    */
  def readSyntheticProfiles(mainFolder: String,
                            subFolders: Iterable[String],
                            applianceOutputFileName: String,
                            lightingOutputFileName: String,
                            ids: Iterable[Int],
                            windowSize: Int): Vector[SpanSlotAccumulatedLoad] = {
    assert(subFolders.size == ids.size, "the number of subFolders is not equal to the number of ids")

    subFolders
      .zip(ids)
      .map {
        case (subFolder, id) =>
          val l = SpanSlotAccumulatedLoad(id,
                                          0,
                                          readSyntheticLoads(
                                            mainFolder + subFolder + applianceOutputFileName,
                                            mainFolder + subFolder + lightingOutputFileName,
                                            windowSize
                                          ))
          l

      }
      .toVector
  }

}

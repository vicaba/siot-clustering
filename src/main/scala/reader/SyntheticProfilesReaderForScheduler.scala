package reader

import test.load.{SingleLoad, AccumulatedLoad, FixedLoad, FlexibleLoad}
import test._

import scala.util.Try

object SyntheticProfilesReaderForScheduler extends TemplateForSyntheticProfilesReader {

  override type SingleLoadOutputType = SingleLoad

  override type AccumulatedLoadOutputType = AccumulatedLoad

  def applyDefault(mainFolder: String,
                   subFolders: Iterable[String],
                   applianceOutputFileName: String,
                   lightingOutputFileName: String,
                   ids: Iterable[Int],
                   windowSize: Int): Vector[AccumulatedLoadOutputType] = {

    apply(
      mainFolder,
      subFolders,
      subFolder => LoadFileAndLoadBuilder(mainFolder + subFolder + applianceOutputFileName, ApplianceLoadBuilder),
      subFolder => LoadFileAndLoadBuilder(mainFolder + subFolder + lightingOutputFileName, FixedLoadBuilder), ids, windowSize
    )
  }

  /**
    *
    * Reads files applianceOutputFileName, lightingOutputFileName for each profile.
    * Directory structure is prepared to be mainFolder/{subFolder}/{applianceOutputFileName|lightingOutputFileName}.
    * Data format is in CSV where there are no column headers and each row starts with a label. The label of the appliance.
    * Data is expected to be synthetically generated by https://github.com/keirstead-group/simelec .
    *
    * @param mainFolder
    * @param subFolders
    * @param applianceFileAndBuilder
    * @param lightingFileAndBuilder
    * @param ids
    * @param windowSize
    * @return
    */
  def apply(mainFolder: String,
            subFolders: Iterable[String],
            applianceFileAndBuilder: String => this.LoadFileAndLoadBuilder,
            lightingFileAndBuilder: String => this.LoadFileAndLoadBuilder,
            ids: Iterable[Int],
            windowSize: Int): Vector[AccumulatedLoadOutputType] = {
    assert(subFolders.size == ids.size, "the number of subFolders is not equal to the number of ids")

    subFolders
      .zip(ids)
      .map {
        case (subFolder, id) =>
          val l = AccumulatedLoad(id,
                                          0,
                                          readSyntheticLoads(
                                            applianceFileAndBuilder(subFolder),
                                            lightingFileAndBuilder(subFolder),
                                            windowSize
                                          ), "")
          l

      }
      .toVector
  }

  object ApplianceLoadBuilder extends LoadBuilder {
    import Appliances._
    override def apply(id: Int, values: Vector[Double], label: String): SingleLoad =
      Try(label match {
        case DishWasher     => FlexibleLoad(id, 0, values, label)
        case TumbleDryer    => FlexibleLoad(id, 0, values, label)
        case WashingMachine => FlexibleLoad(id, 0, values, label)
        case WasherDryer    => FlexibleLoad(id, 0, values, label)
      }).getOrElse(FixedLoadBuilder(id, values, label))
  }

  object FixedLoadBuilder extends LoadBuilder {
    override def apply(id: Int, values: Vector[Double], label: String): SingleLoad =
      FixedLoad(id, 0, values, label)
  }

}
